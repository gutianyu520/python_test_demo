# -*- coding: utf-8 -*-
# @Time : 2021/02/02 13:34
# @Author : Lim Yoona
# @Site : 
# @File : 02_gc.py
# @Software: PyCharm

"""垃圾回收(二)"""

"""
    1. Garbage collection(GC垃圾回收)
        引用计数机制为主，标记清除和分代收集为辅的策略
"""

"""
    引用计数器：
        python中的每个东西都是对象，有一个核心结构体：PyObject
        typedef struct_object {
            int ob_refcnt;
            struct_typeobject *ob_type;
        } PyObject;
        其中 ob_refcnt作为其引用计数，当对象有新的引用就会增加，当引用的对象被删除时，则会减少，当计数为0，表示该对象要被销毁了
        
    优点：
        1.简单
        2.实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。
        
    缺点：
        1.维护引用计数消耗资源
        2.循环引用，导致内存泄漏，引入标记清除和分代收集
    
    python创建对象时，会立即向操作系统申请内存，python在创建对象的时候内部保留一个整数：引用数（初始值是1，当引用指向新的对象时就会变成0，
    此时垃圾回收器立马释放内存）
"""

"""
    循环引用（两个对象互相持有对方的引用，而导致计数不为0，垃圾收集器不会进行回收）
"""

"""
    零代（generation zero）
        1.当出现循环引用时，就需要引入零代算法。python在创建对象时会将其引入零代列表（只是称呼，没有实际形态）
        2.检测对象是否存在循环引用，有的话则计数减1，有一个算一个，这样就可以将引用计数到0的位置，垃圾回收器释放内存，
          释放完内存之后，剩下存活的对象将移到新的链表上：一代链表
    零代就类似于标记清除算法
"""

"""
    关于GC的阈值
        循环引用的对象，比一般对象具有更长的存活时间，因此，随着时间的推移，其引用计数会越来越大，此时就需要引入一个阈值
        通过阈值来控制循环引用的对象是否需要被清除回收，当超过一定阈值时便会触发垃圾回收，释放这些"浮动垃圾"
"""

"""
    弱代假说
        零代过程在一代链表上发生，继续存活的对象会移动到二代链表上，这个过程被称之为提升(promote)
        零代处理最为频繁，其次一代，最后是二代 
        算法理念：年轻的对象朝生夕死，老对象存活时间更长
        根据gc阈值的设定，当达到一定阈值去处理老对象，新对象则不需要通过阈值来开启垃圾收集释放内存
"""














